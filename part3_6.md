Kubernetes is a platform for managing and orchestrating multi-host containerized application environments. It provides both command line and graphical interfaces to – for example – manage deployments, scaling and networking. The early development was made by Google, and the project was subsequently open-sourced. Before platforms of this kind were available, roles responsible for application operations were carrying out these tasks manually. 

Manual deployment carries at least two types of risks. Firstly, as those with industry experience surely know, manipulating the running environment either by scaling or version deployment can be very hazardous and is prone to human error. The process itself might be clearly documentable for example in a checklist or – even more rigorously – in a flowchart format, but it's very easy to type extra characters or press a button by accident (like in the classic Hawaii missile alarm).

Secondly, this type of manual work is simply tedious when done with the degree of care that a successful performance requires. It's considered as a general best practice that especially deployment and scaling of production environments are carried out with a high degree of automation and human monitoring. Pre-production environments like testing and development environments should be completely automated, as this enables faster development cycles when integrated into the continuous integration pipelines.

There are good reasons why Kubernetes is so widely used in the industry. Many cloud services, such as AWS and Google Cloud, provide managed versions of the platform. It has a wide and lively developer community which makes adaptation much more easier. Despite that, there are alternatives which might be more suitable for special use cases or environments of smaller scales. For example, Docker has its Swarm platform which has a gentler learning curve and might be a better suit for environments of a smaller scale.
